// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.base.MessageHeader.proto

#include "common.base.MessageHeader.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_common_2ebase_2eMessageHeader_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMsgObjectInfo_common_2ebase_2eMessageHeader_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2ebase_2eMessageHeader_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMsgSubscribeItem_common_2ebase_2eMessageHeader_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2ebase_2eToken_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMsgTokens_common_2ebase_2eToken_2eproto;
namespace NFdbBase {
class FdbMessageHeaderDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbMessageHeader> _instance;
} _FdbMessageHeader_default_instance_;
class FdbMsgSubscribeItemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbMsgSubscribeItem> _instance;
} _FdbMsgSubscribeItem_default_instance_;
class FdbMsgSubscribeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbMsgSubscribe> _instance;
} _FdbMsgSubscribe_default_instance_;
class FdbMsgErrorInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbMsgErrorInfo> _instance;
} _FdbMsgErrorInfo_default_instance_;
class FdbMsgObjectInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbMsgObjectInfo> _instance;
} _FdbMsgObjectInfo_default_instance_;
class FdbMsgObjectInfoTblDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbMsgObjectInfoTbl> _instance;
} _FdbMsgObjectInfoTbl_default_instance_;
class FdbLogProducerDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbLogProducerData> _instance;
} _FdbLogProducerData_default_instance_;
class FdbTraceProducerDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbTraceProducerData> _instance;
} _FdbTraceProducerData_default_instance_;
class FdbMsgLogConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbMsgLogConfig> _instance;
} _FdbMsgLogConfig_default_instance_;
class FdbTraceConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbTraceConfig> _instance;
} _FdbTraceConfig_default_instance_;
class FdbAuthenticationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FdbAuthentication> _instance;
} _FdbAuthentication_default_instance_;
}  // namespace NFdbBase
static void InitDefaultsscc_info_FdbAuthentication_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbAuthentication_default_instance_;
    new (ptr) ::NFdbBase::FdbAuthentication();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbAuthentication::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FdbAuthentication_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FdbAuthentication_common_2ebase_2eMessageHeader_2eproto}, {
      &scc_info_FdbMsgTokens_common_2ebase_2eToken_2eproto.base,}};

static void InitDefaultsscc_info_FdbLogProducerData_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbLogProducerData_default_instance_;
    new (ptr) ::NFdbBase::FdbLogProducerData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbLogProducerData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbLogProducerData_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbLogProducerData_common_2ebase_2eMessageHeader_2eproto}, {}};

static void InitDefaultsscc_info_FdbMessageHeader_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbMessageHeader_default_instance_;
    new (ptr) ::NFdbBase::FdbMessageHeader();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbMessageHeader::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMessageHeader_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbMessageHeader_common_2ebase_2eMessageHeader_2eproto}, {}};

static void InitDefaultsscc_info_FdbMsgErrorInfo_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbMsgErrorInfo_default_instance_;
    new (ptr) ::NFdbBase::FdbMsgErrorInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbMsgErrorInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMsgErrorInfo_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbMsgErrorInfo_common_2ebase_2eMessageHeader_2eproto}, {}};

static void InitDefaultsscc_info_FdbMsgLogConfig_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbMsgLogConfig_default_instance_;
    new (ptr) ::NFdbBase::FdbMsgLogConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbMsgLogConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMsgLogConfig_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbMsgLogConfig_common_2ebase_2eMessageHeader_2eproto}, {}};

static void InitDefaultsscc_info_FdbMsgObjectInfo_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbMsgObjectInfo_default_instance_;
    new (ptr) ::NFdbBase::FdbMsgObjectInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbMsgObjectInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMsgObjectInfo_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbMsgObjectInfo_common_2ebase_2eMessageHeader_2eproto}, {}};

static void InitDefaultsscc_info_FdbMsgObjectInfoTbl_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbMsgObjectInfoTbl_default_instance_;
    new (ptr) ::NFdbBase::FdbMsgObjectInfoTbl();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbMsgObjectInfoTbl::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FdbMsgObjectInfoTbl_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FdbMsgObjectInfoTbl_common_2ebase_2eMessageHeader_2eproto}, {
      &scc_info_FdbMsgObjectInfo_common_2ebase_2eMessageHeader_2eproto.base,}};

static void InitDefaultsscc_info_FdbMsgSubscribe_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbMsgSubscribe_default_instance_;
    new (ptr) ::NFdbBase::FdbMsgSubscribe();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbMsgSubscribe::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FdbMsgSubscribe_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FdbMsgSubscribe_common_2ebase_2eMessageHeader_2eproto}, {
      &scc_info_FdbMsgSubscribeItem_common_2ebase_2eMessageHeader_2eproto.base,}};

static void InitDefaultsscc_info_FdbMsgSubscribeItem_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbMsgSubscribeItem_default_instance_;
    new (ptr) ::NFdbBase::FdbMsgSubscribeItem();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbMsgSubscribeItem::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbMsgSubscribeItem_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbMsgSubscribeItem_common_2ebase_2eMessageHeader_2eproto}, {}};

static void InitDefaultsscc_info_FdbTraceConfig_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbTraceConfig_default_instance_;
    new (ptr) ::NFdbBase::FdbTraceConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbTraceConfig::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbTraceConfig_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbTraceConfig_common_2ebase_2eMessageHeader_2eproto}, {}};

static void InitDefaultsscc_info_FdbTraceProducerData_common_2ebase_2eMessageHeader_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::NFdbBase::_FdbTraceProducerData_default_instance_;
    new (ptr) ::NFdbBase::FdbTraceProducerData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::NFdbBase::FdbTraceProducerData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_FdbTraceProducerData_common_2ebase_2eMessageHeader_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_FdbTraceProducerData_common_2ebase_2eMessageHeader_2eproto}, {}};

namespace NFdbBase {
bool FdbMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FdbMessageType_strings[9] = {};

static const char FdbMessageType_names[] =
  "MT_BROADCAST"
  "MT_MAX"
  "MT_REPLY"
  "MT_REQUEST"
  "MT_SIDEBAND_REPLY"
  "MT_SIDEBAND_REQUEST"
  "MT_STATUS"
  "MT_SUBSCRIBE_REQ"
  "MT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FdbMessageType_entries[] = {
  { {FdbMessageType_names + 0, 12}, 4 },
  { {FdbMessageType_names + 12, 6}, 8 },
  { {FdbMessageType_names + 18, 8}, 2 },
  { {FdbMessageType_names + 26, 10}, 1 },
  { {FdbMessageType_names + 36, 17}, 6 },
  { {FdbMessageType_names + 53, 19}, 5 },
  { {FdbMessageType_names + 72, 9}, 7 },
  { {FdbMessageType_names + 81, 16}, 3 },
  { {FdbMessageType_names + 97, 10}, 0 },
};

static const int FdbMessageType_entries_by_number[] = {
  8, // 0 -> MT_UNKNOWN
  3, // 1 -> MT_REQUEST
  2, // 2 -> MT_REPLY
  7, // 3 -> MT_SUBSCRIBE_REQ
  0, // 4 -> MT_BROADCAST
  5, // 5 -> MT_SIDEBAND_REQUEST
  4, // 6 -> MT_SIDEBAND_REPLY
  6, // 7 -> MT_STATUS
  1, // 8 -> MT_MAX
};

const std::string& FdbMessageType_Name(
    FdbMessageType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FdbMessageType_entries,
          FdbMessageType_entries_by_number,
          9, FdbMessageType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FdbMessageType_entries,
      FdbMessageType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FdbMessageType_strings[idx].get();
}
bool FdbMessageType_Parse(
    const std::string& name, FdbMessageType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FdbMessageType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<FdbMessageType>(int_value);
  }
  return success;
}
bool FdbTraceLogLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FdbTraceLogLevel_strings[7] = {};

static const char FdbTraceLogLevel_names[] =
  "FDB_LL_DEBUG"
  "FDB_LL_ERROR"
  "FDB_LL_FATAL"
  "FDB_LL_INFO"
  "FDB_LL_SILENT"
  "FDB_LL_VERBOSE"
  "FDB_LL_WARNING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FdbTraceLogLevel_entries[] = {
  { {FdbTraceLogLevel_names + 0, 12}, 1 },
  { {FdbTraceLogLevel_names + 12, 12}, 4 },
  { {FdbTraceLogLevel_names + 24, 12}, 5 },
  { {FdbTraceLogLevel_names + 36, 11}, 2 },
  { {FdbTraceLogLevel_names + 47, 13}, 6 },
  { {FdbTraceLogLevel_names + 60, 14}, 0 },
  { {FdbTraceLogLevel_names + 74, 14}, 3 },
};

static const int FdbTraceLogLevel_entries_by_number[] = {
  5, // 0 -> FDB_LL_VERBOSE
  0, // 1 -> FDB_LL_DEBUG
  3, // 2 -> FDB_LL_INFO
  6, // 3 -> FDB_LL_WARNING
  1, // 4 -> FDB_LL_ERROR
  2, // 5 -> FDB_LL_FATAL
  4, // 6 -> FDB_LL_SILENT
};

const std::string& FdbTraceLogLevel_Name(
    FdbTraceLogLevel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FdbTraceLogLevel_entries,
          FdbTraceLogLevel_entries_by_number,
          7, FdbTraceLogLevel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FdbTraceLogLevel_entries,
      FdbTraceLogLevel_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FdbTraceLogLevel_strings[idx].get();
}
bool FdbTraceLogLevel_Parse(
    const std::string& name, FdbTraceLogLevel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FdbTraceLogLevel_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<FdbTraceLogLevel>(int_value);
  }
  return success;
}
bool FdbMessageLoggerCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FdbMessageLoggerCode_strings[8] = {};

static const char FdbMessageLoggerCode_names[] =
  "NTF_FDBUS_LOG"
  "NTF_LOGGER_CONFIG"
  "NTF_TRACE_CONFIG"
  "NTF_TRACE_LOG"
  "REQ_FDBUS_LOG"
  "REQ_LOGGER_CONFIG"
  "REQ_TRACE_CONFIG"
  "REQ_TRACE_LOG";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FdbMessageLoggerCode_entries[] = {
  { {FdbMessageLoggerCode_names + 0, 13}, 6 },
  { {FdbMessageLoggerCode_names + 13, 17}, 4 },
  { {FdbMessageLoggerCode_names + 30, 16}, 5 },
  { {FdbMessageLoggerCode_names + 46, 13}, 7 },
  { {FdbMessageLoggerCode_names + 59, 13}, 0 },
  { {FdbMessageLoggerCode_names + 72, 17}, 2 },
  { {FdbMessageLoggerCode_names + 89, 16}, 3 },
  { {FdbMessageLoggerCode_names + 105, 13}, 1 },
};

static const int FdbMessageLoggerCode_entries_by_number[] = {
  4, // 0 -> REQ_FDBUS_LOG
  7, // 1 -> REQ_TRACE_LOG
  5, // 2 -> REQ_LOGGER_CONFIG
  6, // 3 -> REQ_TRACE_CONFIG
  1, // 4 -> NTF_LOGGER_CONFIG
  2, // 5 -> NTF_TRACE_CONFIG
  0, // 6 -> NTF_FDBUS_LOG
  3, // 7 -> NTF_TRACE_LOG
};

const std::string& FdbMessageLoggerCode_Name(
    FdbMessageLoggerCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FdbMessageLoggerCode_entries,
          FdbMessageLoggerCode_entries_by_number,
          8, FdbMessageLoggerCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FdbMessageLoggerCode_entries,
      FdbMessageLoggerCode_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FdbMessageLoggerCode_strings[idx].get();
}
bool FdbMessageLoggerCode_Parse(
    const std::string& name, FdbMessageLoggerCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FdbMessageLoggerCode_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<FdbMessageLoggerCode>(int_value);
  }
  return success;
}
bool FdbSubscribeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FdbSubscribeType_strings[2] = {};

static const char FdbSubscribeType_names[] =
  "SUB_TYPE_NORMAL"
  "SUB_TYPE_ON_REQUEST";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FdbSubscribeType_entries[] = {
  { {FdbSubscribeType_names + 0, 15}, 0 },
  { {FdbSubscribeType_names + 15, 19}, 1 },
};

static const int FdbSubscribeType_entries_by_number[] = {
  0, // 0 -> SUB_TYPE_NORMAL
  1, // 1 -> SUB_TYPE_ON_REQUEST
};

const std::string& FdbSubscribeType_Name(
    FdbSubscribeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FdbSubscribeType_entries,
          FdbSubscribeType_entries_by_number,
          2, FdbSubscribeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FdbSubscribeType_entries,
      FdbSubscribeType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FdbSubscribeType_strings[idx].get();
}
bool FdbSubscribeType_Parse(
    const std::string& name, FdbSubscribeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FdbSubscribeType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<FdbSubscribeType>(int_value);
  }
  return success;
}

// ===================================================================

void FdbMessageHeader::InitAsDefaultInstance() {
}
class FdbMessageHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbMessageHeader>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_sender_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_broadcast_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_send_or_arrive_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_reply_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

FdbMessageHeader::FdbMessageHeader()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbMessageHeader)
}
FdbMessageHeader::FdbMessageHeader(const FdbMessageHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sender_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sender_name()) {
    sender_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_name_);
  }
  broadcast_filter_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_broadcast_filter()) {
    broadcast_filter_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.broadcast_filter_);
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&reply_time_) -
    reinterpret_cast<char*>(&type_)) + sizeof(reply_time_));
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbMessageHeader)
}

void FdbMessageHeader::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbMessageHeader_common_2ebase_2eMessageHeader_2eproto.base);
  sender_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  broadcast_filter_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reply_time_) -
      reinterpret_cast<char*>(&type_)) + sizeof(reply_time_));
}

FdbMessageHeader::~FdbMessageHeader() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbMessageHeader)
  SharedDtor();
}

void FdbMessageHeader::SharedDtor() {
  sender_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  broadcast_filter_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FdbMessageHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbMessageHeader& FdbMessageHeader::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbMessageHeader_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbMessageHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbMessageHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sender_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      broadcast_filter_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&payload_size_) -
        reinterpret_cast<char*>(&type_)) + sizeof(payload_size_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&send_or_arrive_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reply_time_) -
        reinterpret_cast<char*>(&send_or_arrive_time_)) + sizeof(reply_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbMessageHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .NFdbBase.FdbMessageType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NFdbBase::FdbMessageType_IsValid(val))) {
            _internal_set_type(static_cast<::NFdbBase::FdbMessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required int32 serial_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_serial_number(&has_bits);
          serial_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_code(&has_bits);
          code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 flag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_flag(&has_bits);
          flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 object_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_object_id(&has_bits);
          object_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 payload_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_payload_size(&has_bits);
          payload_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string sender_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_sender_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string broadcast_filter = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_broadcast_filter(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 send_or_arrive_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_send_or_arrive_time(&has_bits);
          send_or_arrive_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 reply_time = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_reply_time(&has_bits);
          reply_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbMessageHeader::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbMessageHeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .NFdbBase.FdbMessageType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required int32 serial_number = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_serial_number(), target);
  }

  // required int32 code = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_code(), target);
  }

  // required uint32 flag = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_flag(), target);
  }

  // required uint32 object_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_object_id(), target);
  }

  // required uint32 payload_size = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_payload_size(), target);
  }

  // optional string sender_name = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_sender_name(), target);
  }

  // optional string broadcast_filter = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_broadcast_filter(), target);
  }

  // optional uint64 send_or_arrive_time = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_send_or_arrive_time(), target);
  }

  // optional uint64 reply_time = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(11, this->_internal_reply_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbMessageHeader)
  return target;
}

size_t FdbMessageHeader::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NFdbBase.FdbMessageHeader)
  size_t total_size = 0;

  if (has_type()) {
    // required .NFdbBase.FdbMessageType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (has_serial_number()) {
    // required int32 serial_number = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_serial_number());
  }

  if (has_code()) {
    // required int32 code = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_code());
  }

  if (has_flag()) {
    // required uint32 flag = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_flag());
  }

  if (has_object_id()) {
    // required uint32 object_id = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_object_id());
  }

  if (has_payload_size()) {
    // required uint32 payload_size = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_payload_size());
  }

  return total_size;
}
size_t FdbMessageHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbMessageHeader)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000000fc) ^ 0x000000fc) == 0) {  // All required fields are present.
    // required .NFdbBase.FdbMessageType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

    // required int32 serial_number = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_serial_number());

    // required int32 code = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_code());

    // required uint32 flag = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_flag());

    // required uint32 object_id = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_object_id());

    // required uint32 payload_size = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_payload_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string sender_name = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sender_name());
    }

    // optional string broadcast_filter = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_broadcast_filter());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 send_or_arrive_time = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_send_or_arrive_time());
    }

    // optional uint64 reply_time = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_reply_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbMessageHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbMessageHeader*>(
      &from));
}

void FdbMessageHeader::MergeFrom(const FdbMessageHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbMessageHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      sender_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      broadcast_filter_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.broadcast_filter_);
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      serial_number_ = from.serial_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      code_ = from.code_;
    }
    if (cached_has_bits & 0x00000020u) {
      flag_ = from.flag_;
    }
    if (cached_has_bits & 0x00000040u) {
      object_id_ = from.object_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      payload_size_ = from.payload_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      send_or_arrive_time_ = from.send_or_arrive_time_;
    }
    if (cached_has_bits & 0x00000200u) {
      reply_time_ = from.reply_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbMessageHeader::CopyFrom(const FdbMessageHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbMessageHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbMessageHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000fc) != 0x000000fc) return false;
  return true;
}

void FdbMessageHeader::InternalSwap(FdbMessageHeader* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sender_name_.Swap(&other->sender_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  broadcast_filter_.Swap(&other->broadcast_filter_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(type_, other->type_);
  swap(serial_number_, other->serial_number_);
  swap(code_, other->code_);
  swap(flag_, other->flag_);
  swap(object_id_, other->object_id_);
  swap(payload_size_, other->payload_size_);
  swap(send_or_arrive_time_, other->send_or_arrive_time_);
  swap(reply_time_, other->reply_time_);
}

std::string FdbMessageHeader::GetTypeName() const {
  return "NFdbBase.FdbMessageHeader";
}


// ===================================================================

void FdbMsgSubscribeItem::InitAsDefaultInstance() {
}
class FdbMsgSubscribeItem::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbMsgSubscribeItem>()._has_bits_);
  static void set_has_msg_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

FdbMsgSubscribeItem::FdbMsgSubscribeItem()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbMsgSubscribeItem)
}
FdbMsgSubscribeItem::FdbMsgSubscribeItem(const FdbMsgSubscribeItem& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  filter_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_filter()) {
    filter_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.filter_);
  }
  ::memcpy(&msg_code_, &from.msg_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&msg_code_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbMsgSubscribeItem)
}

void FdbMsgSubscribeItem::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbMsgSubscribeItem_common_2ebase_2eMessageHeader_2eproto.base);
  filter_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&msg_code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&msg_code_)) + sizeof(type_));
}

FdbMsgSubscribeItem::~FdbMsgSubscribeItem() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbMsgSubscribeItem)
  SharedDtor();
}

void FdbMsgSubscribeItem::SharedDtor() {
  filter_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FdbMsgSubscribeItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbMsgSubscribeItem& FdbMsgSubscribeItem::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbMsgSubscribeItem_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbMsgSubscribeItem::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbMsgSubscribeItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    filter_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&msg_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&msg_code_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbMsgSubscribeItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 msg_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_msg_code(&has_bits);
          msg_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string filter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_filter(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .NFdbBase.FdbSubscribeType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NFdbBase::FdbSubscribeType_IsValid(val))) {
            _internal_set_type(static_cast<::NFdbBase::FdbSubscribeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbMsgSubscribeItem::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbMsgSubscribeItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 msg_code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_msg_code(), target);
  }

  // optional string filter = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_filter(), target);
  }

  // optional .NFdbBase.FdbSubscribeType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbMsgSubscribeItem)
  return target;
}

size_t FdbMsgSubscribeItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbMsgSubscribeItem)
  size_t total_size = 0;

  // required int32 msg_code = 1;
  if (has_msg_code()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_msg_code());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string filter = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filter());
  }

  // optional .NFdbBase.FdbSubscribeType type = 3;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbMsgSubscribeItem::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbMsgSubscribeItem*>(
      &from));
}

void FdbMsgSubscribeItem::MergeFrom(const FdbMsgSubscribeItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbMsgSubscribeItem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      filter_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.filter_);
    }
    if (cached_has_bits & 0x00000002u) {
      msg_code_ = from.msg_code_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbMsgSubscribeItem::CopyFrom(const FdbMsgSubscribeItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbMsgSubscribeItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbMsgSubscribeItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void FdbMsgSubscribeItem::InternalSwap(FdbMsgSubscribeItem* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  filter_.Swap(&other->filter_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(msg_code_, other->msg_code_);
  swap(type_, other->type_);
}

std::string FdbMsgSubscribeItem::GetTypeName() const {
  return "NFdbBase.FdbMsgSubscribeItem";
}


// ===================================================================

void FdbMsgSubscribe::InitAsDefaultInstance() {
}
class FdbMsgSubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbMsgSubscribe>()._has_bits_);
};

FdbMsgSubscribe::FdbMsgSubscribe()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbMsgSubscribe)
}
FdbMsgSubscribe::FdbMsgSubscribe(const FdbMsgSubscribe& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      notify_list_(from.notify_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbMsgSubscribe)
}

void FdbMsgSubscribe::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbMsgSubscribe_common_2ebase_2eMessageHeader_2eproto.base);
}

FdbMsgSubscribe::~FdbMsgSubscribe() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbMsgSubscribe)
  SharedDtor();
}

void FdbMsgSubscribe::SharedDtor() {
}

void FdbMsgSubscribe::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbMsgSubscribe& FdbMsgSubscribe::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbMsgSubscribe_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbMsgSubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbMsgSubscribe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  notify_list_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbMsgSubscribe::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .NFdbBase.FdbMsgSubscribeItem notify_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_notify_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbMsgSubscribe::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbMsgSubscribe)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .NFdbBase.FdbMsgSubscribeItem notify_list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_notify_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_notify_list(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbMsgSubscribe)
  return target;
}

size_t FdbMsgSubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbMsgSubscribe)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NFdbBase.FdbMsgSubscribeItem notify_list = 1;
  total_size += 1UL * this->_internal_notify_list_size();
  for (const auto& msg : this->notify_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbMsgSubscribe::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbMsgSubscribe*>(
      &from));
}

void FdbMsgSubscribe::MergeFrom(const FdbMsgSubscribe& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbMsgSubscribe)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  notify_list_.MergeFrom(from.notify_list_);
}

void FdbMsgSubscribe::CopyFrom(const FdbMsgSubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbMsgSubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbMsgSubscribe::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->notify_list())) return false;
  return true;
}

void FdbMsgSubscribe::InternalSwap(FdbMsgSubscribe* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  notify_list_.InternalSwap(&other->notify_list_);
}

std::string FdbMsgSubscribe::GetTypeName() const {
  return "NFdbBase.FdbMsgSubscribe";
}


// ===================================================================

void FdbMsgErrorInfo::InitAsDefaultInstance() {
}
class FdbMsgErrorInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbMsgErrorInfo>()._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FdbMsgErrorInfo::FdbMsgErrorInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbMsgErrorInfo)
}
FdbMsgErrorInfo::FdbMsgErrorInfo(const FdbMsgErrorInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_description()) {
    description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  error_code_ = from.error_code_;
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbMsgErrorInfo)
}

void FdbMsgErrorInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbMsgErrorInfo_common_2ebase_2eMessageHeader_2eproto.base);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  error_code_ = 0;
}

FdbMsgErrorInfo::~FdbMsgErrorInfo() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbMsgErrorInfo)
  SharedDtor();
}

void FdbMsgErrorInfo::SharedDtor() {
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FdbMsgErrorInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbMsgErrorInfo& FdbMsgErrorInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbMsgErrorInfo_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbMsgErrorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbMsgErrorInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    description_.ClearNonDefaultToEmptyNoArena();
  }
  error_code_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbMsgErrorInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_error_code(&has_bits);
          error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_description(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbMsgErrorInfo::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbMsgErrorInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 error_code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_error_code(), target);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbMsgErrorInfo)
  return target;
}

size_t FdbMsgErrorInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbMsgErrorInfo)
  size_t total_size = 0;

  // required int32 error_code = 1;
  if (has_error_code()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_error_code());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string description = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbMsgErrorInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbMsgErrorInfo*>(
      &from));
}

void FdbMsgErrorInfo::MergeFrom(const FdbMsgErrorInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbMsgErrorInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      description_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000002u) {
      error_code_ = from.error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbMsgErrorInfo::CopyFrom(const FdbMsgErrorInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbMsgErrorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbMsgErrorInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void FdbMsgErrorInfo::InternalSwap(FdbMsgErrorInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(error_code_, other->error_code_);
}

std::string FdbMsgErrorInfo::GetTypeName() const {
  return "NFdbBase.FdbMsgErrorInfo";
}


// ===================================================================

void FdbMsgObjectInfo::InitAsDefaultInstance() {
}
class FdbMsgObjectInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbMsgObjectInfo>()._has_bits_);
  static void set_has_obj_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_obj_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FdbMsgObjectInfo::FdbMsgObjectInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbMsgObjectInfo)
}
FdbMsgObjectInfo::FdbMsgObjectInfo(const FdbMsgObjectInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  obj_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_obj_name()) {
    obj_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.obj_name_);
  }
  obj_id_ = from.obj_id_;
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbMsgObjectInfo)
}

void FdbMsgObjectInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbMsgObjectInfo_common_2ebase_2eMessageHeader_2eproto.base);
  obj_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  obj_id_ = 0u;
}

FdbMsgObjectInfo::~FdbMsgObjectInfo() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbMsgObjectInfo)
  SharedDtor();
}

void FdbMsgObjectInfo::SharedDtor() {
  obj_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FdbMsgObjectInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbMsgObjectInfo& FdbMsgObjectInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbMsgObjectInfo_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbMsgObjectInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbMsgObjectInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    obj_name_.ClearNonDefaultToEmptyNoArena();
  }
  obj_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbMsgObjectInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 obj_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_obj_id(&has_bits);
          obj_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string obj_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_obj_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbMsgObjectInfo::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbMsgObjectInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 obj_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_obj_id(), target);
  }

  // optional string obj_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_obj_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbMsgObjectInfo)
  return target;
}

size_t FdbMsgObjectInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbMsgObjectInfo)
  size_t total_size = 0;

  // required uint32 obj_id = 1;
  if (has_obj_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_obj_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string obj_name = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_obj_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbMsgObjectInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbMsgObjectInfo*>(
      &from));
}

void FdbMsgObjectInfo::MergeFrom(const FdbMsgObjectInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbMsgObjectInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      obj_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.obj_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      obj_id_ = from.obj_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbMsgObjectInfo::CopyFrom(const FdbMsgObjectInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbMsgObjectInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbMsgObjectInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void FdbMsgObjectInfo::InternalSwap(FdbMsgObjectInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  obj_name_.Swap(&other->obj_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(obj_id_, other->obj_id_);
}

std::string FdbMsgObjectInfo::GetTypeName() const {
  return "NFdbBase.FdbMsgObjectInfo";
}


// ===================================================================

void FdbMsgObjectInfoTbl::InitAsDefaultInstance() {
}
class FdbMsgObjectInfoTbl::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbMsgObjectInfoTbl>()._has_bits_);
};

FdbMsgObjectInfoTbl::FdbMsgObjectInfoTbl()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbMsgObjectInfoTbl)
}
FdbMsgObjectInfoTbl::FdbMsgObjectInfoTbl(const FdbMsgObjectInfoTbl& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      info_(from.info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbMsgObjectInfoTbl)
}

void FdbMsgObjectInfoTbl::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbMsgObjectInfoTbl_common_2ebase_2eMessageHeader_2eproto.base);
}

FdbMsgObjectInfoTbl::~FdbMsgObjectInfoTbl() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbMsgObjectInfoTbl)
  SharedDtor();
}

void FdbMsgObjectInfoTbl::SharedDtor() {
}

void FdbMsgObjectInfoTbl::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbMsgObjectInfoTbl& FdbMsgObjectInfoTbl::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbMsgObjectInfoTbl_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbMsgObjectInfoTbl::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbMsgObjectInfoTbl)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  info_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbMsgObjectInfoTbl::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .NFdbBase.FdbMsgObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbMsgObjectInfoTbl::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbMsgObjectInfoTbl)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .NFdbBase.FdbMsgObjectInfo info = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_info_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_info(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbMsgObjectInfoTbl)
  return target;
}

size_t FdbMsgObjectInfoTbl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbMsgObjectInfoTbl)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NFdbBase.FdbMsgObjectInfo info = 1;
  total_size += 1UL * this->_internal_info_size();
  for (const auto& msg : this->info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbMsgObjectInfoTbl::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbMsgObjectInfoTbl*>(
      &from));
}

void FdbMsgObjectInfoTbl::MergeFrom(const FdbMsgObjectInfoTbl& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbMsgObjectInfoTbl)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  info_.MergeFrom(from.info_);
}

void FdbMsgObjectInfoTbl::CopyFrom(const FdbMsgObjectInfoTbl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbMsgObjectInfoTbl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbMsgObjectInfoTbl::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->info())) return false;
  return true;
}

void FdbMsgObjectInfoTbl::InternalSwap(FdbMsgObjectInfoTbl* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  info_.InternalSwap(&other->info_);
}

std::string FdbMsgObjectInfoTbl::GetTypeName() const {
  return "NFdbBase.FdbMsgObjectInfoTbl";
}


// ===================================================================

void FdbLogProducerData::InitAsDefaultInstance() {
}
class FdbLogProducerData::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbLogProducerData>()._has_bits_);
  static void set_has_logger_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sender_host_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sender_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_receiver_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_service_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_time_stamp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_string(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_msg_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

FdbLogProducerData::FdbLogProducerData()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbLogProducerData)
}
FdbLogProducerData::FdbLogProducerData(const FdbLogProducerData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sender_host_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sender_host_name()) {
    sender_host_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_host_name_);
  }
  sender_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sender_name()) {
    sender_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_name_);
  }
  receiver_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_receiver_name()) {
    receiver_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.receiver_name_);
  }
  service_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_service_name()) {
    service_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.service_name_);
  }
  ::memcpy(&logger_pid_, &from.logger_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&object_id_) -
    reinterpret_cast<char*>(&logger_pid_)) + sizeof(object_id_));
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbLogProducerData)
}

void FdbLogProducerData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbLogProducerData_common_2ebase_2eMessageHeader_2eproto.base);
  sender_host_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sender_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  receiver_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  service_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&logger_pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&object_id_) -
      reinterpret_cast<char*>(&logger_pid_)) + sizeof(object_id_));
}

FdbLogProducerData::~FdbLogProducerData() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbLogProducerData)
  SharedDtor();
}

void FdbLogProducerData::SharedDtor() {
  sender_host_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sender_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  receiver_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  service_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FdbLogProducerData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbLogProducerData& FdbLogProducerData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbLogProducerData_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbLogProducerData::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbLogProducerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      sender_host_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      sender_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      receiver_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      service_name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&logger_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&serial_number_) -
        reinterpret_cast<char*>(&logger_pid_)) + sizeof(serial_number_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&time_stamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&object_id_) -
        reinterpret_cast<char*>(&time_stamp_)) + sizeof(object_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbLogProducerData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 logger_pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_logger_pid(&has_bits);
          logger_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string sender_host_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_sender_host_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string sender_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_sender_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string receiver_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_receiver_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string service_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_service_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .NFdbBase.FdbMessageType type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NFdbBase::FdbMessageType_IsValid(val))) {
            _internal_set_type(static_cast<::NFdbBase::FdbMessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required int32 code = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_code(&has_bits);
          code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 serial_number = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_serial_number(&has_bits);
          serial_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int64 time_stamp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_time_stamp(&has_bits);
          time_stamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool is_string = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_is_string(&has_bits);
          is_string_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 msg_payload_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_msg_payload_size(&has_bits);
          msg_payload_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 object_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_object_id(&has_bits);
          object_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbLogProducerData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbLogProducerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 logger_pid = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_logger_pid(), target);
  }

  // required string sender_host_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sender_host_name(), target);
  }

  // required string sender_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sender_name(), target);
  }

  // required string receiver_name = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_receiver_name(), target);
  }

  // required string service_name = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_service_name(), target);
  }

  // required .NFdbBase.FdbMessageType type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_type(), target);
  }

  // required int32 code = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_code(), target);
  }

  // required int32 serial_number = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_serial_number(), target);
  }

  // required int64 time_stamp = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_time_stamp(), target);
  }

  // required bool is_string = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_string(), target);
  }

  // required int32 msg_payload_size = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_msg_payload_size(), target);
  }

  // required int32 object_id = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_object_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbLogProducerData)
  return target;
}

size_t FdbLogProducerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NFdbBase.FdbLogProducerData)
  size_t total_size = 0;

  if (has_sender_host_name()) {
    // required string sender_host_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sender_host_name());
  }

  if (has_sender_name()) {
    // required string sender_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sender_name());
  }

  if (has_receiver_name()) {
    // required string receiver_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_receiver_name());
  }

  if (has_service_name()) {
    // required string service_name = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service_name());
  }

  if (has_logger_pid()) {
    // required int32 logger_pid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_logger_pid());
  }

  if (has_type()) {
    // required .NFdbBase.FdbMessageType type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (has_code()) {
    // required int32 code = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_code());
  }

  if (has_serial_number()) {
    // required int32 serial_number = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_serial_number());
  }

  if (has_time_stamp()) {
    // required int64 time_stamp = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_time_stamp());
  }

  if (has_is_string()) {
    // required bool is_string = 10;
    total_size += 1 + 1;
  }

  if (has_msg_payload_size()) {
    // required int32 msg_payload_size = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_msg_payload_size());
  }

  if (has_object_id()) {
    // required int32 object_id = 12;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_object_id());
  }

  return total_size;
}
size_t FdbLogProducerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbLogProducerData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000fff) ^ 0x00000fff) == 0) {  // All required fields are present.
    // required string sender_host_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sender_host_name());

    // required string sender_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sender_name());

    // required string receiver_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_receiver_name());

    // required string service_name = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service_name());

    // required int32 logger_pid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_logger_pid());

    // required .NFdbBase.FdbMessageType type = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

    // required int32 code = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_code());

    // required int32 serial_number = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_serial_number());

    // required int64 time_stamp = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_time_stamp());

    // required bool is_string = 10;
    total_size += 1 + 1;

    // required int32 msg_payload_size = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_msg_payload_size());

    // required int32 object_id = 12;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_object_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbLogProducerData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbLogProducerData*>(
      &from));
}

void FdbLogProducerData::MergeFrom(const FdbLogProducerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbLogProducerData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      sender_host_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_host_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      sender_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      receiver_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.receiver_name_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      service_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.service_name_);
    }
    if (cached_has_bits & 0x00000010u) {
      logger_pid_ = from.logger_pid_;
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000040u) {
      code_ = from.code_;
    }
    if (cached_has_bits & 0x00000080u) {
      serial_number_ = from.serial_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      time_stamp_ = from.time_stamp_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_string_ = from.is_string_;
    }
    if (cached_has_bits & 0x00000400u) {
      msg_payload_size_ = from.msg_payload_size_;
    }
    if (cached_has_bits & 0x00000800u) {
      object_id_ = from.object_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbLogProducerData::CopyFrom(const FdbLogProducerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbLogProducerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbLogProducerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000fff) != 0x00000fff) return false;
  return true;
}

void FdbLogProducerData::InternalSwap(FdbLogProducerData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sender_host_name_.Swap(&other->sender_host_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sender_name_.Swap(&other->sender_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  receiver_name_.Swap(&other->receiver_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  service_name_.Swap(&other->service_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(logger_pid_, other->logger_pid_);
  swap(type_, other->type_);
  swap(code_, other->code_);
  swap(serial_number_, other->serial_number_);
  swap(time_stamp_, other->time_stamp_);
  swap(is_string_, other->is_string_);
  swap(msg_payload_size_, other->msg_payload_size_);
  swap(object_id_, other->object_id_);
}

std::string FdbLogProducerData::GetTypeName() const {
  return "NFdbBase.FdbLogProducerData";
}


// ===================================================================

void FdbTraceProducerData::InitAsDefaultInstance() {
}
class FdbTraceProducerData::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbTraceProducerData>()._has_bits_);
  static void set_has_trace_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sender_host_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time_stamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_trace_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

FdbTraceProducerData::FdbTraceProducerData()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbTraceProducerData)
}
FdbTraceProducerData::FdbTraceProducerData(const FdbTraceProducerData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sender_host_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sender_host_name()) {
    sender_host_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_host_name_);
  }
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_tag()) {
    tag_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.tag_);
  }
  ::memcpy(&trace_pid_, &from.trace_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_stamp_) -
    reinterpret_cast<char*>(&trace_pid_)) + sizeof(time_stamp_));
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbTraceProducerData)
}

void FdbTraceProducerData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbTraceProducerData_common_2ebase_2eMessageHeader_2eproto.base);
  sender_host_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&trace_pid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_stamp_) -
      reinterpret_cast<char*>(&trace_pid_)) + sizeof(time_stamp_));
}

FdbTraceProducerData::~FdbTraceProducerData() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbTraceProducerData)
  SharedDtor();
}

void FdbTraceProducerData::SharedDtor() {
  sender_host_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FdbTraceProducerData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbTraceProducerData& FdbTraceProducerData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbTraceProducerData_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbTraceProducerData::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbTraceProducerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sender_host_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      tag_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&trace_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_stamp_) -
        reinterpret_cast<char*>(&trace_pid_)) + sizeof(time_stamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbTraceProducerData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 trace_pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_trace_pid(&has_bits);
          trace_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string sender_host_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_sender_host_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string tag = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_mutable_tag(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int64 time_stamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_time_stamp(&has_bits);
          time_stamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .NFdbBase.FdbTraceLogLevel trace_level = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NFdbBase::FdbTraceLogLevel_IsValid(val))) {
            _internal_set_trace_level(static_cast<::NFdbBase::FdbTraceLogLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbTraceProducerData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbTraceProducerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 trace_pid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_trace_pid(), target);
  }

  // required string sender_host_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sender_host_name(), target);
  }

  // required string tag = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_tag(), target);
  }

  // required int64 time_stamp = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_time_stamp(), target);
  }

  // required .NFdbBase.FdbTraceLogLevel trace_level = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_trace_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbTraceProducerData)
  return target;
}

size_t FdbTraceProducerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NFdbBase.FdbTraceProducerData)
  size_t total_size = 0;

  if (has_sender_host_name()) {
    // required string sender_host_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sender_host_name());
  }

  if (has_tag()) {
    // required string tag = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());
  }

  if (has_trace_pid()) {
    // required int32 trace_pid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_trace_pid());
  }

  if (has_trace_level()) {
    // required .NFdbBase.FdbTraceLogLevel trace_level = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_trace_level());
  }

  if (has_time_stamp()) {
    // required int64 time_stamp = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_time_stamp());
  }

  return total_size;
}
size_t FdbTraceProducerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbTraceProducerData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string sender_host_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sender_host_name());

    // required string tag = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tag());

    // required int32 trace_pid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_trace_pid());

    // required .NFdbBase.FdbTraceLogLevel trace_level = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_trace_level());

    // required int64 time_stamp = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_time_stamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbTraceProducerData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbTraceProducerData*>(
      &from));
}

void FdbTraceProducerData::MergeFrom(const FdbTraceProducerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbTraceProducerData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      sender_host_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sender_host_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      tag_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.tag_);
    }
    if (cached_has_bits & 0x00000004u) {
      trace_pid_ = from.trace_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      trace_level_ = from.trace_level_;
    }
    if (cached_has_bits & 0x00000010u) {
      time_stamp_ = from.time_stamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbTraceProducerData::CopyFrom(const FdbTraceProducerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbTraceProducerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbTraceProducerData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  return true;
}

void FdbTraceProducerData::InternalSwap(FdbTraceProducerData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sender_host_name_.Swap(&other->sender_host_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  tag_.Swap(&other->tag_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(trace_pid_, other->trace_pid_);
  swap(trace_level_, other->trace_level_);
  swap(time_stamp_, other->time_stamp_);
}

std::string FdbTraceProducerData::GetTypeName() const {
  return "NFdbBase.FdbTraceProducerData";
}


// ===================================================================

void FdbMsgLogConfig::InitAsDefaultInstance() {
}
class FdbMsgLogConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbMsgLogConfig>()._has_bits_);
  static void set_has_global_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable_reply(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_broadcast(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_enable_subscribe(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_raw_data_clipping_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

FdbMsgLogConfig::FdbMsgLogConfig()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbMsgLogConfig)
}
FdbMsgLogConfig::FdbMsgLogConfig(const FdbMsgLogConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      host_while_list_(from.host_while_list_),
      endpoint_while_list_(from.endpoint_while_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&global_enable_, &from.global_enable_,
    static_cast<size_t>(reinterpret_cast<char*>(&raw_data_clipping_size_) -
    reinterpret_cast<char*>(&global_enable_)) + sizeof(raw_data_clipping_size_));
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbMsgLogConfig)
}

void FdbMsgLogConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbMsgLogConfig_common_2ebase_2eMessageHeader_2eproto.base);
  ::memset(&global_enable_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&raw_data_clipping_size_) -
      reinterpret_cast<char*>(&global_enable_)) + sizeof(raw_data_clipping_size_));
}

FdbMsgLogConfig::~FdbMsgLogConfig() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbMsgLogConfig)
  SharedDtor();
}

void FdbMsgLogConfig::SharedDtor() {
}

void FdbMsgLogConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbMsgLogConfig& FdbMsgLogConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbMsgLogConfig_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbMsgLogConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbMsgLogConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  host_while_list_.Clear();
  endpoint_while_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&global_enable_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&raw_data_clipping_size_) -
        reinterpret_cast<char*>(&global_enable_)) + sizeof(raw_data_clipping_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbMsgLogConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool global_enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_global_enable(&has_bits);
          global_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool enable_request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_enable_request(&has_bits);
          enable_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool enable_reply = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_enable_reply(&has_bits);
          enable_reply_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool enable_broadcast = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_enable_broadcast(&has_bits);
          enable_broadcast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool enable_subscribe = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_enable_subscribe(&has_bits);
          enable_subscribe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 raw_data_clipping_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_raw_data_clipping_size(&has_bits);
          raw_data_clipping_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string host_while_list = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_host_while_list(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string endpoint_while_list = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_endpoint_while_list(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbMsgLogConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbMsgLogConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool global_enable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_global_enable(), target);
  }

  // required bool enable_request = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_enable_request(), target);
  }

  // required bool enable_reply = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_enable_reply(), target);
  }

  // required bool enable_broadcast = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_enable_broadcast(), target);
  }

  // required bool enable_subscribe = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_subscribe(), target);
  }

  // required int32 raw_data_clipping_size = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_raw_data_clipping_size(), target);
  }

  // repeated string host_while_list = 7;
  for (int i = 0, n = this->_internal_host_while_list_size(); i < n; i++) {
    const auto& s = this->_internal_host_while_list(i);
    target = stream->WriteString(7, s, target);
  }

  // repeated string endpoint_while_list = 8;
  for (int i = 0, n = this->_internal_endpoint_while_list_size(); i < n; i++) {
    const auto& s = this->_internal_endpoint_while_list(i);
    target = stream->WriteString(8, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbMsgLogConfig)
  return target;
}

size_t FdbMsgLogConfig::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NFdbBase.FdbMsgLogConfig)
  size_t total_size = 0;

  if (has_global_enable()) {
    // required bool global_enable = 1;
    total_size += 1 + 1;
  }

  if (has_enable_request()) {
    // required bool enable_request = 2;
    total_size += 1 + 1;
  }

  if (has_enable_reply()) {
    // required bool enable_reply = 3;
    total_size += 1 + 1;
  }

  if (has_enable_broadcast()) {
    // required bool enable_broadcast = 4;
    total_size += 1 + 1;
  }

  if (has_enable_subscribe()) {
    // required bool enable_subscribe = 5;
    total_size += 1 + 1;
  }

  if (has_raw_data_clipping_size()) {
    // required int32 raw_data_clipping_size = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_raw_data_clipping_size());
  }

  return total_size;
}
size_t FdbMsgLogConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbMsgLogConfig)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required bool global_enable = 1;
    total_size += 1 + 1;

    // required bool enable_request = 2;
    total_size += 1 + 1;

    // required bool enable_reply = 3;
    total_size += 1 + 1;

    // required bool enable_broadcast = 4;
    total_size += 1 + 1;

    // required bool enable_subscribe = 5;
    total_size += 1 + 1;

    // required int32 raw_data_clipping_size = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_raw_data_clipping_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string host_while_list = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(host_while_list_.size());
  for (int i = 0, n = host_while_list_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      host_while_list_.Get(i));
  }

  // repeated string endpoint_while_list = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(endpoint_while_list_.size());
  for (int i = 0, n = endpoint_while_list_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      endpoint_while_list_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbMsgLogConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbMsgLogConfig*>(
      &from));
}

void FdbMsgLogConfig::MergeFrom(const FdbMsgLogConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbMsgLogConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  host_while_list_.MergeFrom(from.host_while_list_);
  endpoint_while_list_.MergeFrom(from.endpoint_while_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      global_enable_ = from.global_enable_;
    }
    if (cached_has_bits & 0x00000002u) {
      enable_request_ = from.enable_request_;
    }
    if (cached_has_bits & 0x00000004u) {
      enable_reply_ = from.enable_reply_;
    }
    if (cached_has_bits & 0x00000008u) {
      enable_broadcast_ = from.enable_broadcast_;
    }
    if (cached_has_bits & 0x00000010u) {
      enable_subscribe_ = from.enable_subscribe_;
    }
    if (cached_has_bits & 0x00000020u) {
      raw_data_clipping_size_ = from.raw_data_clipping_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbMsgLogConfig::CopyFrom(const FdbMsgLogConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbMsgLogConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbMsgLogConfig::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void FdbMsgLogConfig::InternalSwap(FdbMsgLogConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  host_while_list_.InternalSwap(&other->host_while_list_);
  endpoint_while_list_.InternalSwap(&other->endpoint_while_list_);
  swap(global_enable_, other->global_enable_);
  swap(enable_request_, other->enable_request_);
  swap(enable_reply_, other->enable_reply_);
  swap(enable_broadcast_, other->enable_broadcast_);
  swap(enable_subscribe_, other->enable_subscribe_);
  swap(raw_data_clipping_size_, other->raw_data_clipping_size_);
}

std::string FdbMsgLogConfig::GetTypeName() const {
  return "NFdbBase.FdbMsgLogConfig";
}


// ===================================================================

void FdbTraceConfig::InitAsDefaultInstance() {
}
class FdbTraceConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbTraceConfig>()._has_bits_);
  static void set_has_global_enable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_log_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FdbTraceConfig::FdbTraceConfig()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbTraceConfig)
}
FdbTraceConfig::FdbTraceConfig(const FdbTraceConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      host_while_list_(from.host_while_list_),
      tag_while_list_(from.tag_while_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&global_enable_, &from.global_enable_,
    static_cast<size_t>(reinterpret_cast<char*>(&log_level_) -
    reinterpret_cast<char*>(&global_enable_)) + sizeof(log_level_));
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbTraceConfig)
}

void FdbTraceConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbTraceConfig_common_2ebase_2eMessageHeader_2eproto.base);
  ::memset(&global_enable_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&log_level_) -
      reinterpret_cast<char*>(&global_enable_)) + sizeof(log_level_));
}

FdbTraceConfig::~FdbTraceConfig() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbTraceConfig)
  SharedDtor();
}

void FdbTraceConfig::SharedDtor() {
}

void FdbTraceConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbTraceConfig& FdbTraceConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbTraceConfig_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbTraceConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbTraceConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  host_while_list_.Clear();
  tag_while_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&global_enable_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&log_level_) -
        reinterpret_cast<char*>(&global_enable_)) + sizeof(log_level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbTraceConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool global_enable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_global_enable(&has_bits);
          global_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .NFdbBase.FdbTraceLogLevel log_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NFdbBase::FdbTraceLogLevel_IsValid(val))) {
            _internal_set_log_level(static_cast<::NFdbBase::FdbTraceLogLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated string host_while_list = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_host_while_list(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string tag_while_list = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(_internal_add_tag_while_list(), ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbTraceConfig::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbTraceConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool global_enable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_global_enable(), target);
  }

  // required .NFdbBase.FdbTraceLogLevel log_level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_log_level(), target);
  }

  // repeated string host_while_list = 7;
  for (int i = 0, n = this->_internal_host_while_list_size(); i < n; i++) {
    const auto& s = this->_internal_host_while_list(i);
    target = stream->WriteString(7, s, target);
  }

  // repeated string tag_while_list = 8;
  for (int i = 0, n = this->_internal_tag_while_list_size(); i < n; i++) {
    const auto& s = this->_internal_tag_while_list(i);
    target = stream->WriteString(8, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbTraceConfig)
  return target;
}

size_t FdbTraceConfig::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:NFdbBase.FdbTraceConfig)
  size_t total_size = 0;

  if (has_global_enable()) {
    // required bool global_enable = 1;
    total_size += 1 + 1;
  }

  if (has_log_level()) {
    // required .NFdbBase.FdbTraceLogLevel log_level = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_log_level());
  }

  return total_size;
}
size_t FdbTraceConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbTraceConfig)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bool global_enable = 1;
    total_size += 1 + 1;

    // required .NFdbBase.FdbTraceLogLevel log_level = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_log_level());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string host_while_list = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(host_while_list_.size());
  for (int i = 0, n = host_while_list_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      host_while_list_.Get(i));
  }

  // repeated string tag_while_list = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(tag_while_list_.size());
  for (int i = 0, n = tag_while_list_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      tag_while_list_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbTraceConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbTraceConfig*>(
      &from));
}

void FdbTraceConfig::MergeFrom(const FdbTraceConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbTraceConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  host_while_list_.MergeFrom(from.host_while_list_);
  tag_while_list_.MergeFrom(from.tag_while_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      global_enable_ = from.global_enable_;
    }
    if (cached_has_bits & 0x00000002u) {
      log_level_ = from.log_level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FdbTraceConfig::CopyFrom(const FdbTraceConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbTraceConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbTraceConfig::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void FdbTraceConfig::InternalSwap(FdbTraceConfig* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  host_while_list_.InternalSwap(&other->host_while_list_);
  tag_while_list_.InternalSwap(&other->tag_while_list_);
  swap(global_enable_, other->global_enable_);
  swap(log_level_, other->log_level_);
}

std::string FdbTraceConfig::GetTypeName() const {
  return "NFdbBase.FdbTraceConfig";
}


// ===================================================================

void FdbAuthentication::InitAsDefaultInstance() {
  ::NFdbBase::_FdbAuthentication_default_instance_._instance.get_mutable()->token_list_ = const_cast< ::NFdbBase::FdbMsgTokens*>(
      ::NFdbBase::FdbMsgTokens::internal_default_instance());
}
class FdbAuthentication::_Internal {
 public:
  using HasBits = decltype(std::declval<FdbAuthentication>()._has_bits_);
  static const ::NFdbBase::FdbMsgTokens& token_list(const FdbAuthentication* msg);
  static void set_has_token_list(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::NFdbBase::FdbMsgTokens&
FdbAuthentication::_Internal::token_list(const FdbAuthentication* msg) {
  return *msg->token_list_;
}
void FdbAuthentication::clear_token_list() {
  if (token_list_ != nullptr) token_list_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
FdbAuthentication::FdbAuthentication()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NFdbBase.FdbAuthentication)
}
FdbAuthentication::FdbAuthentication(const FdbAuthentication& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_token_list()) {
    token_list_ = new ::NFdbBase::FdbMsgTokens(*from.token_list_);
  } else {
    token_list_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:NFdbBase.FdbAuthentication)
}

void FdbAuthentication::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FdbAuthentication_common_2ebase_2eMessageHeader_2eproto.base);
  token_list_ = nullptr;
}

FdbAuthentication::~FdbAuthentication() {
  // @@protoc_insertion_point(destructor:NFdbBase.FdbAuthentication)
  SharedDtor();
}

void FdbAuthentication::SharedDtor() {
  if (this != internal_default_instance()) delete token_list_;
}

void FdbAuthentication::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FdbAuthentication& FdbAuthentication::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FdbAuthentication_common_2ebase_2eMessageHeader_2eproto.base);
  return *internal_default_instance();
}


void FdbAuthentication::Clear() {
// @@protoc_insertion_point(message_clear_start:NFdbBase.FdbAuthentication)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(token_list_ != nullptr);
    token_list_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FdbAuthentication::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .NFdbBase.FdbMsgTokens token_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_list(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FdbAuthentication::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NFdbBase.FdbAuthentication)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .NFdbBase.FdbMsgTokens token_list = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::token_list(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NFdbBase.FdbAuthentication)
  return target;
}

size_t FdbAuthentication::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NFdbBase.FdbAuthentication)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .NFdbBase.FdbMsgTokens token_list = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *token_list_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FdbAuthentication::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const FdbAuthentication*>(
      &from));
}

void FdbAuthentication::MergeFrom(const FdbAuthentication& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:NFdbBase.FdbAuthentication)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_token_list()) {
    _internal_mutable_token_list()->::NFdbBase::FdbMsgTokens::MergeFrom(from._internal_token_list());
  }
}

void FdbAuthentication::CopyFrom(const FdbAuthentication& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NFdbBase.FdbAuthentication)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FdbAuthentication::IsInitialized() const {
  if (has_token_list()) {
    if (!this->token_list_->IsInitialized()) return false;
  }
  return true;
}

void FdbAuthentication::InternalSwap(FdbAuthentication* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(token_list_, other->token_list_);
}

std::string FdbAuthentication::GetTypeName() const {
  return "NFdbBase.FdbAuthentication";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace NFdbBase
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbMessageHeader* Arena::CreateMaybeMessage< ::NFdbBase::FdbMessageHeader >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbMessageHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbMsgSubscribeItem* Arena::CreateMaybeMessage< ::NFdbBase::FdbMsgSubscribeItem >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbMsgSubscribeItem >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbMsgSubscribe* Arena::CreateMaybeMessage< ::NFdbBase::FdbMsgSubscribe >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbMsgSubscribe >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbMsgErrorInfo* Arena::CreateMaybeMessage< ::NFdbBase::FdbMsgErrorInfo >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbMsgErrorInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbMsgObjectInfo* Arena::CreateMaybeMessage< ::NFdbBase::FdbMsgObjectInfo >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbMsgObjectInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbMsgObjectInfoTbl* Arena::CreateMaybeMessage< ::NFdbBase::FdbMsgObjectInfoTbl >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbMsgObjectInfoTbl >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbLogProducerData* Arena::CreateMaybeMessage< ::NFdbBase::FdbLogProducerData >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbLogProducerData >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbTraceProducerData* Arena::CreateMaybeMessage< ::NFdbBase::FdbTraceProducerData >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbTraceProducerData >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbMsgLogConfig* Arena::CreateMaybeMessage< ::NFdbBase::FdbMsgLogConfig >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbMsgLogConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbTraceConfig* Arena::CreateMaybeMessage< ::NFdbBase::FdbTraceConfig >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbTraceConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::NFdbBase::FdbAuthentication* Arena::CreateMaybeMessage< ::NFdbBase::FdbAuthentication >(Arena* arena) {
  return Arena::CreateInternal< ::NFdbBase::FdbAuthentication >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
